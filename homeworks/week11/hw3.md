## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

首先來說雜湊以及加密的區別，加密與雜湊很像，都是把明文變成密碼文。所謂明文是指原始的訊息文字，可能有意義也可能沒有語意。而這些明文可能是重要資訊，例如個資、機密情報等，也可能是通關密碼(password)這類可以取得權限與資源的文字。為了防止明文被截取之後洩漏，會將明文以特殊方式重新組合，這個過程稱作加密，而加密之後的產物就是密碼文，而把密碼文反轉成明文就是解碼。這樣如果密碼文落入其他人手中，對他們而言這就是完全沒有意義的文字，因為他們不知道原始的加密方法，要解碼就需要很多時間與資源。比較簡易與有名的加密例如凱撒加密，將訊息的字母全部往前 n 個或者全部往後 m 個，這樣會讓原本有有意義的明文變成沒有意義的密碼文。另外像是摩斯電碼也是一種加密法。  
加密雖然可以讓不知道加密方法的人在看到密碼文的時候覺得是亂碼，不過只要知道加密方法，或者加密方法太過簡陋都會讓加密的保護效果消失。以摩斯電碼傳輸的訊息，只要截取方也知道摩斯電碼，這些摩斯電碼對截取方來說就跟明文無異；而如果是凱撒加密，只要夠有耐心將去測試位移量也是可以用暴力的方式解碼。這些密碼文之所以可以被解開，可能因為這些密碼文與明文有一對一的唯一關並且有可逆性，所以只要知道加密方法並且逆推就可以得到明文。所以這樣的加密並不能保證密碼文的安全性。其實加密擁有可逆性是正常的，因為一開始使用加密最終目的還是要將密碼文解碼獲得裡面的資訊。然而如果內容是金鑰、個資等連持有密碼者都不能知道的資訊，那就可以使用一些不可逆的加密法，而雜湊就是這樣一種加密法。  
加密因為目的的關係，必須要有可逆性，然而雜湊一開始的設計目標就是讓任何人都不能解碼。程式中所使用的雜湊法，最終會產生長度相同的密碼文，而且不同的明文可能產生同樣的密碼文，這種狀況稱作「碰撞」。因為雜湊的設計就是為了不可逆，而且即便知道加密法，想要逆推也會發現同樣的密碼文與明文的對應關係不是唯一，這會造成解碼上的困難。雜湊形成的密碼文想要破譯需要很長時間的計算，就算計算完成也不能保證結果正確，所以是個可以很好保存金鑰等文字資訊的方式。  
如前所述，資料庫中的通關密碼理論上只有使用者可以知道，就算連資料庫管理員也不能得知，再加上為了讓當最壞的狀況發生，也就是資料庫外洩時，使用者的通關密碼也不會因此外流，所以必須要用雜湊加密之後再存入資料庫，保證除了會員本人之外能接觸到通關密碼資訊的人都只能看到不可逆的密碼文，而不是明文以及可以逆推的密碼文。

## `include`、`require`、`include_once`、`require_once` 的差別

首先，include 和 require 雖然都可以引用其他 PHP 檔案，兩者的差別有一點是如果 include 呼叫的檔案不存在，程式碼會顯示找不到檔案，但是仍然執行接下來的內容；而如果使用 require 而呼叫的檔案不存在，則程式碼會停止運行。我從字面上理解的話，include 是包含的意思，所以只要有做包含動作，並不會去檢查是否真的有這個東西，也不會認真檢查，如果沒有這個東西會顯示警告訊息但是繼續執行程式；而 require 有需要的意思，所以不但會將檔案納入，也會去檢查是否真的有這個東西，如果沒有這個東西就會終止程式。
include_once 和 require_once 彼此的差異與 include 以及 require 差不多，重點在於 _once。舉例來說，include_once 執行時會先檢查在這之前是否已經有引用相同的檔案，如果已經引用過就不會再引用一次，require_once 也是一樣。會使用這點是因為，如果再引用的檔案中有宣告自己寫的韓式，重複引用會造成函式重複宣告，這會讓程式產生錯誤，所以可以利用 _once 的特性防止這種狀況產生。

## 請說明 SQL Injection 的攻擊原理以及防範方法

PHP 或者其他處理後端的程式，幾乎都會與資料庫做連結並且使用 SQL 或者其他程式語言取用以及更改資料庫資料。以 PHP 為例，會先用 PHP 建立與資料庫的連線與取得權限，接著利用 PHP 對資料庫下各種指令達成目標。SQL Injection 最常舉的例子是使用網頁提供的搜尋功能來攻擊資料庫。網頁的搜尋功能大致上是使用者輸入要搜尋的字串，字串被送到伺服器由 PHP 檔案進行處理轉換成資料庫指令，PHP 檔案再去抓取執行結果經由轉換後輸出回給用戶。這種攻擊可以成立有下列幾個原因。首先是因為 PHP 要使用用戶提供的字串，還有一個點就是 PHP 發出的資料指令是由單純字串拼接方式組成，並且直接發到資料庫，以及 PHP 檔所連結的資料庫使用者權限過大。  
首先因為需要使用用戶提供的字串，所以如果有惡意用戶輸入特定字串，就有可能造成 PHP 檔中的資料庫指令被惡意加料，加入原本意料之外的指令。例如最常見的 `"1' OR '1'='1"` 就是利用資料庫的查詢指令，在拼接的部分讓資料庫可以選出表單中所有的資料，更甚者，可以用更複雜的指令調取資料庫中其他表格，或者將資料庫資料刪除等惡意攻擊。而這些字串攻擊有效是因為在 PHP 檔案中使用單純的字串拼接，並且沒有對特殊字元做跳脫(escape)，或是做特別處理，以至於 PHP 檔完全接受用戶提供的字串，組合之後變成超乎預期的指令。還有，即便這些指令有效，也要 PHP 檔連結的使用者有足夠權限，才可能得到資訊或者對資料庫做攻擊，而在開發時，為求方便常會連結擁有所有權限的使用者。  
防範方法的第一個心法就是「不要相信使用者提供的資訊」，任何使用者可以對伺服器發出訊息的地方都要做防範，以及對所有使用者提供的資訊都要做處理。例如在不需要用到特舒服到的地方可以限制使用者無法輸入特殊符號，也要設定伺服器接收到這些資訊時如果內涵不合規格的字元就要拒絕。而如果是需要使用特殊字元的時候，就要對字元做跳脫處理。如果是使用 PHP 就對所有資料庫指令使用 prepare statement，這是一個函式，可以將指令參數化，經由函式的運算可以避免因為特殊字元造成指令有預想之外的功能，最後是在產品上線時，將 PHP 檔或者用戶可以存取的後端檔案連結權限較小的使用者，這樣即便能夠對資料庫下指令，也會因為權限問題導致指令無效，達到保護效果。

##  請說明 XSS 的攻擊原理以及防範方法

XSS 的原理與 SQL Injection 類似，主要的差別是 SQL Injection 是利用後端程式的漏洞，而 XSS 是利用 HTML 以及 JS 的漏洞。像是第一週的留言板如果沒有對 XSS 做處理，就會被植入惡意的 JS 指令，愉快犯可能只會讓頁面顯示奇怪的東西，然而竟然可以執行 JS，就代表任何可以由 JS 存取的資訊，包括竊取資訊以及更改頁面或者使用者權限。防止方式也是可以從後端處理，在不需要特殊字元的地方規範不得使用，這樣就無法藉由這些管道載網頁植入標籤更改網頁。而如果是需要使用特殊符號的地方，例如論壇貼文或者留言板，那就需要在顯示這些從使用者發出的資訊時使用跳脫，讓這些字元以純文字的方式顯示，不會被解讀為網頁標籤的一部份。
簡而言之，也是同樣一句話：「不要相信使用者提供的資訊」，如果迫不得已要使用，記得不用全盤照收，而是要經由轉換確定都變成較無傷害的型態才可以使用。


## 請說明 CSRF 的攻擊原理以及防範方法

CSRF 全名為 Cross Site Request Forgery，直翻的話「是跨網站偽造請求」，這是一種盜用身份的攻擊方法，最近討論度很高的 Youtuber 被盜事件就是這類的攻擊。
CSRF 首先要講的是網站如何驗證身份，通常是利用 cookies 或者 cookies based session 儲存使用者資訊，這類方式很像換發通行證的概念。當網站確認使用者資料庫有這名使用者時，就會發給使用者一個 cookie 並且記錄這個 cookie 對應的使用者是哪一位，這樣使用者在這個網站瀏覽只要帶著 cookie 就可以辨識身份，而這個 cookie 會儲存在瀏覽器中，也就是會跟著電腦走。同樣的使用者在不同的瀏覽器或者不同的電腦登入，就會得到新的 cookie。
照理來說這樣就可以確保 cookie 與使用者的對應關係，但是只有對應關係就是個問題。因為這套系統只認 cookie，所以只要能夠獲取 cookie 就可以竊取身份。甚至不用取得 cookie，只要誘騙使用者對某個地方發 request 就可以，例如如果駭客想要使用某個特定人的帳號做某個行動，例如使用我的帳號轉帳給駭客。他大可不用竊取我的網路銀行帳密，只要他能夠偽造一個向網路銀行系統發出轉帳的請求，並從我的瀏覽器帶著我的 cookie 發送，這樣就可以達到他的目的了。要做這樣的，做直覺也最多人聽過的案例就是釣魚連結或者釣魚信件。這類的攻擊就是將 request 包裝成無害或者會讓人想點擊的連結，例如假冒通知中獎、通知帳號盜用等信件，並附上連結讓只要讓使用者點擊連結，他們就中招了。最近的 Youtuber 帳號盜用風波也是使用類似的手法，例如他們會偽裝成廠商想要談業配，並且附上產品的連結或者試用版軟體，當不知情的 Youtuber 點擊或者執行軟體時，就會中招。這類的攻擊一般使用者能做的防範較少，比較好的習慣是每次使用完網站就登出，不要讓 cookie 保持在登入狀態，如此就算發出請求，也會因為沒有登入而無效。還有就是不要在公用電腦登入個人帳號。
在這方面，其實除了使用者之外，開發者也要設想該如何防範。這種攻擊方法有個特色就是是從外部網域發送 request，所以其中一個防範重點可以放在如何分辨外部網域來的 request 並且阻止後續動作。第一種方法是可以檢查 request 的 referer header，這是記錄此 request 是從哪個網域發送的，不過因為並沒有一個確定安全的檢驗方法，再加上不是所有瀏覽器都支援這個 header，所以並不算是個好方法。第二種方法是由 server 在同網域的時候先產生一個 token 儲存在 cookie 中並且讓表單發出 request 的時候帶上這個 token，而後端就可以去驗證表單與 cookie 的 token 是否相符。如此一來，從不同網域發送的 request 就不會帶著相同的 token，因為駭客不會得到 server 端發送的 token，也就無法通過這層驗證。  
上述兩種方式對於一般使用者來說比較無感，因為這些方式是使用者在畫面無法看到以及使用經驗很難察覺的。對使用者比較有感的阻絕方法是雙重認證，不論是網頁的圖形認證或者是手機語音、簡訊、email 的雙重認證，都可以確認這個 request 是經過使用者本人（當然要排除手機以及 email 被盜用）。這種認證方法並不是保證是從同一個網域發送，而是要保證是由使用者發送，不過因為程序繁瑣。因為還要經由第二個網頁、設備等進行認證，所以在使用者體驗上會比較繁瑣，通常只會用在比較重大的 request 上，例如登入、金流服務等就會使用，以確保是由本人發送 request。