## 什麼是 DOM？

我對 DOM 的認識跟字母順序差不多一樣。  
首先是 D，一開始 DOM 對我來說只是一個新的語法，我只知道在瀏覽器上可以運行 `document` 但是在 Node.js 上沒有用，以及這可以幫我找到 html 裡面的某個東西。
然後在我寫作業的時候，我逐漸了解 O 代表的意義，在取用 document 的東西時，會用很多 dot `.`，就這樣 dot 來 dot 去，就可以把這個元素的所有屬性、狀態、形式、甚至是家譜上下十八代都找出來。尤其是當我用 log 加爆看事件的時候，發現元素可以一直點一直點一直點，才恍然大悟原來這是一個很大的 `object` 啊！  
又多看了一些之後，發現這些東西的是有規則的，到最後當我試著不要看 log 訊息，憑著自己的想法慢慢推敲把正確的元素抓出來，我明白了為何這是一個 `model`。  
`DOM`用我的話來說，就是一個模組化的 html 文件物件，透過它可以在瀏覽器上用 JS 操作 html 的內容。

## 事件傳遞機制的順序是什麼；什麼是冒泡，什麼又是捕獲？

事件傳遞用我的話來比喻，很像是搜救隊救難流程。  
當搜救隊收到求救訊號，他們就會從基地前往搜救訊號的發射地，到了發射地之後援救目標，最後再把目標帶回基地。  
當瀏覽器中有個事件發生，事件留從瀏覽器視窗開始往事件發生的地方走，一路走到 `target`，這就是第一階段「捕獲」。  
到達 `target` 後即進入第二階段「目標」。  
接著事件流會再往回走回到視窗，當離開 `trget` 時就是第三階段「冒泡」。  
基本上，每個事件發生的時候，事件傳遞就會像這樣先由上往下到目標後再由下往上回去，不過這也有特例，比如說事件 `invalid` 就不會冒泡，如果要在上層監聽其事件，就只能在捕獲階段。

## 什麼是 event delegation，為什麼我們需要它？

`event delegation`是運用事件傳遞機制讓開發者可以在事件發生上層監聽事件的方法。  
當在某個元素下的多個子元素，這些子元素彼此十分類似，比如說都是按鈕或者都是文字輸入，又或者要監聽同樣的事件，這時把每個子元素都加上事件監聽會讓程式碼不易閱讀與維護。還有，如果使用 JS 設計動態網頁，新加入的子元素除非特別處理，否則不會有事件監聽，這在實作上會是一個大問題。  
此時就可以使用 event delegation 在父元素加上事件監聽，因為事件傳遞機制會先捕獲再冒泡，事件一定都會傳遞到父元素，所以可以在這邊監聽，就可以掌握下面所有子元素的相同事件。即便用 JS 動態加入子元素，因為監聽是在父元素，不用特別加事件監聽就可以達到監聽的效果。  

## event.preventDefault() 跟 event.stopPropagation() 差在哪裡，可以舉個範例嗎？

`event.preventDefault()`是阻止事件接下來的預設行為，例如當`<a></a>`元素被點擊，其預設行為就是開啟連結，如果在元素加上監聽器，並且在 callback 中呼叫 `event.preventDefault` 就會阻止元素開啟連結。還有一個例子就是表單送出，當監聽表單送出事件，並且在 callback 中呼叫 `event.preventDefault`就會阻擋表單送出。
`event.stopPropagation()`是阻止事件傳遞，在捕獲階段就是阻止事件往下傳遞，在冒泡階段就是阻止事件向上傳遞。重要的是只是阻止事件流，瀏覽器還是會執行預設行為。這個可以用在事件監聽上面，當子元代理素監聽孫元素，而且父元素代理監聽子元素時，假設監聽器都裝在冒泡階段。如果要子元素與父元素各自的代理監聽不相互干擾，就可以在子元素的代理監聽上加上 `event.stopPropagation()`這樣就可以阻止事件繼續往上冒泡，在父元素的監聽器就不會收到孫元素的事件傳遞。
